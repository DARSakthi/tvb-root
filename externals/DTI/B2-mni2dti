#!/bin/sh

## --- 8/14/2011 --- ##

## PURPOSE ##
# - performs subject-to-MNI and subject DTI-to-T1 coregistrations and T1 segmentation

## SOFTWARE REQUIREMENTS ##
# - N3
# - ANTS
# - FSL

## NOTES ##
# - run after dticalc
# - assumes that the first image of the 4D DTI image is a b0

#=======================================================================================

### PREP SCRIPT ###

## check arguments ##
if [ ${#} -ne 1 ]; then 
  echo ""
  echo " Error: Must supply subject pfx as first argument,"; 
  echo " and the following are required in the subject's directory:"
  echo "   - <pfx>_T1.img"
  echo "   - <pfx>_*DTI*_ec.img"
  echo ""
  exit
fi

## change into subject's directory ##
pfx=${1}
if [ ! -d ${pfx} ]; then echo "Error: \"${pfx}\" directory does not exist"; exit; fi
cd ${pfx}

#=======================================================================================

### ===> VARIABLES <=== ###

## filename for T1 image ##
t1=`ls ${pfx}_T1.img | sed "s/\.img//" `
if [ ${t1}x = "x" ]; then echo "Error:  No T1 found"; exit; fi

## filename for eddy corrected DTI image  ##
dti=`ls ${pfx}_*DTI*_ec.img | sed "s/\.img//"`
if [ ${dti}x = "x" ]; then echo "Error:  No DTI found"; exit; fi

## filename for optional T2 image, if found it will be used as an intermediary in the registration from T1 to DTI ##
t2=`ls ${pfx}_*T2.img | sed "s/\.img//"`

## filename for optional FL image ##
fl=`ls ${pfx}_FL.img | sed "s/\.img//"`

## filename for optional HfB image ##
hfb=`ls ${pfx}_*HfB*.img | sed "s/\.img//"`

## directory containing MNI templates ##
mnidir="/home/erin/standard_brains"

## filenames for MNI templates ##
mni="${mnidir}/MNI152_T1_1mm"
mnim="${mnidir}/MNI152_T1_1mm_brain"
cortical="${mnidir}/MNI152_T1_1mm_cocomac_cortical_20110512"
subcortical="${mnidir}/MNI152_T1_1mm_subcortical_20110512"
leftm="${mnidir}/MNI152_T1_1mm_left_side_only"
rightm="${mnidir}/MNI152_T1_1mm_right_side_only"
mnicm="${mnidir}/MNI152_T1_1mm_brain_masked4cortical"
mniscm="${mnidir}/MNI152_T1_1mm_brain_masked4subcortical"

## MNI to T1 nonlinear registration parameters ##
mni2t1="-m PR[ ${t1}.hdr, ${mni}.hdr, 1, 4 ] -t SyN[ 0.5 ] -r Gauss [ 3.0, 0.1 ] -i 100x100x50x0  --number-of-affine-iterations 1000x1000x100"

## T1 to DTI rigid-body registration parameters ##
t12dti="-m MI[ ${dti}_b0.hdr, ${t1}.hdr, 1, 4 ] -i 0 --number-of-affine-iterations 1000x0x0  --do-rigid true"

## T2 to DTI nonlinear registration parameters ##
t22dti="-m PR[ ${dti}_b0.hdr, ${t2}.hdr , 1, 4 ] -t SyN [ 0.25, 2, 0.01 ] -i 100x100x50 --number-of-affine-iterations 1000x0x0 --do-rigid true --MI-option 64x32000"

## T1 to T2 rigid-body registration parameters ##
t12t2="-m MI[ ${t2}.hdr, ${t1}.hdr, 1, 32 ] -i 0 --number-of-affine-iterations 1000x0x0 --do-rigid true  --MI-option 64x32000"
# ==>  iterations should be 1000x100x100 but the above was visually verified for all sb/vhad subjects so i'm leaving as is for now <== ##

## N3 parameters for T1 inhomogeneity correction ##
nu="-iterations 50 -stop 0.001 -distance 150"

## flag for dementia brains, if set to 1, a t1flair minimizing lesions on the T1 will be created and used for the segmentation, (FLAIR/HfB required) ##
dementia="0"

## FLAIR to T1 rigid-body registration parameters ##
fl2t1="-m MI[ ${t1}.hdr, ${fl}.hdr, 1, 32 ] -i 0 --number-of-affine-iterations 1000x0x0  --do-rigid true"

## MNI to T1 nonlinear registration parameters for dementia brains ##
if [ ${dementia} -eq "1" ]; then
  mni2t1="-m PR[ ${pfx}_t1_masked.hdr, ${mnim}.hdr, 1, 4 ] -t SyN[ 0.5, 2.0, 0.05 ] -r Gauss [ 3.0, 0.1 ] -i 100x100x50x0  --number-of-affine-iterations 1000x1000x100"
fi


#=======================================================================================

### DEMENTIA SPECIFIC ### 

if [ ${dementia} -eq 1 ]; then

  ## filename for FLAIR image ##
  fl=`ls ${pfx}_*FL.img| sed "s/\.img//"`
  if [ ${fl}x = "x" ]; then echo "Error:  No FLAIR found"; exit; fi
  if [ ${hfb}x = "x" ]; then echo "Error:  No HfB found"; exit; fi
  
  ## FLAIR to T1 rigid-body registration ##
  ANTS 3 ${fl2t1}  -o ${pfx}_fl_to_t1_.hdr

  ## FLAIR to T1 rigid-body reslice ##
  WarpImageMultiTransform 3 ${fl}.hdr ${pfx}_fl_to_t1.hdr -R ${t1}.img ${pfx}_fl_to_t1_Affine.txt


fi

#=======================================================================================

### PROCESSING COREGISTRATIONS ###

## create 3D b0 image (assumes b0 is the first image in the 4D DTI volume) ## 
imgmath ${dti}.img -min ${dti}.img ${dti}_b0.img
fslchfiletype ANALYZE ${dti}_b0.img
rm ${dti}_b0.mat

if [ ! -e ${t2}.hdr ]; then
  ## T1 to DTI registration without T2 ##
  
  ## T1 to DTI rigid body registration ##
  ANTS 3 ${t12dti} -o ${pfx}_t1_to_dti_.hdr
  
  ## T1 to DTI reslice parameters ##
  t12dtiParameters="${pfx}_t1_to_dti_Affine.txt"

else
  
  ## T1 to DTI registration with T2 ##
  
  ## T1 to T2 rigid-body registration ##
  ANTS 3 ${t12t2} -o ${pfx}_t1_to_t2_.hdr
  
  WarpImageMultiTransform 3 ${t1}.hdr ${pfx}_t1_to_t2.hdr -R ${t2}.hdr ${pfx}_t1_to_t2_Affine.txt
  WarpImageMultiTransform 3 ${t2}.hdr ${pfx}_t2_to_t1.hdr -R ${t1}.hdr -i ${pfx}_t1_to_t2_Affine.txt
  
  ## T2 to DTI nonlinear registration ##
  ANTS 3 ${t22dti} -o ${pfx}_t2_to_dti_.hdr
  WarpImageMultiTransform 3 ${t2}.hdr ${pfx}_t2_to_dti.hdr -R ${dti}_b0.hdr ${pfx}_t2_to_dti_Warp.img ${pfx}_t2_to_dti_Affine.txt
  
  ## T1 to DTI reslice parameters ##
  t12dtiParameters="${pfx}_t2_to_dti_Warp.hdr ${pfx}_t2_to_dti_Affine.txt ${pfx}_t1_to_t2_Affine.txt"

fi

## mask T1 with HfB if it exists (will be necessary for dementia mni to t1 registration next)
if [ -e ${hfb}.img ]; then
  mask_img ${t1} ${hfb} -o ${pfx}_t1_masked -m 0 2 3 4 5 6 7
fi

## MNI to T1 nonlinear registration ##
ANTS 3 ${mni2t1} -o ${pfx}_mni_to_t1_.hdr 

## MNI to T1 nonlinear reslice ##
WarpImageMultiTransform 3 ${mni}.hdr ${pfx}_mni_to_t1.hdr -R ${t1}.hdr  ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt
WarpImageMultiTransform 3 ${mnim}.hdr ${pfx}_mnim_to_t1.hdr -R ${t1}.hdr  ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt

## T1 to DTI rigid body reslice ##
WarpImageMultiTransform 3 ${t1}.hdr  ${pfx}_t1_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} 

## MNI cortical cocomac to DTI reslice ##
WarpImageMultiTransform 3 ${cortical}.hdr ${pfx}_cocomac_cortical_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN

## MNI subcortical cocomac to DTI reslice ##
WarpImageMultiTransform 3 ${subcortical}.hdr ${pfx}_subcortical_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN

## MNI cortical cocomac to T1 reslice ##
WarpImageMultiTransform 3 ${cortical}.hdr ${pfx}_cocomac_cortical_to_t1.hdr -R ${t1}.hdr  ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN

## MNI subcortical to T1 reslice ##
WarpImageMultiTransform 3 ${subcortical}.hdr ${pfx}_subcortical_to_t1.hdr -R ${t1}.hdr  ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN

## MNI left, right, cortical and subcortical masks to DTI reslice ###
WarpImageMultiTransform 3 ${leftm}.hdr ${pfx}_leftm_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN
WarpImageMultiTransform 3 ${rightm}.hdr ${pfx}_rightm_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN
WarpImageMultiTransform 3 ${mnicm}.hdr ${pfx}_mnicm_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN
WarpImageMultiTransform 3 ${mniscm}.hdr ${pfx}_mniscm_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} ${pfx}_mni_to_t1_Warp.hdr ${pfx}_mni_to_t1_Affine.txt --use-NN

## T1 to MNI reslice ##
WarpImageMultiTransform 3 ${t1}.hdr ${pfx}_t1_to_mni.hdr -R ${subcortical}.hdr -i ${pfx}_mni_to_t1_Affine.txt ${pfx}_mni_to_t1_InverseWarp.hdr


#=======================================================================================

### PROCESSING SEGMENTATION ###

## create masked T1 using masked MNI template T1 or HfB if it is exists ##
if [ ! -e ${hfb}.img ]; then
  imgmath ${pfx}_mnim_to_t1.img -thr 0 ${pfx}_mnim_to_t1_int.img -short
  gsmooth16 ${pfx}_mnim_to_t1_int 2 2 2 ${pfx}_mnim_to_t1_int_smoothed -r -s
  imgmath ${pfx}_mnim_to_t1_int_smoothed.img -bin ${pfx}_brainmask.img -char
  imgmath ${t1}.img -mas ${pfx}_brainmask.img ${pfx}_t1_masked.img 
  rm ${pfx}_mnim_to_t1_int.*
  rm ${pfx}_mnim_to_t1_int_smoothed.*
fi
## (else ${pfx}_t1_masked.img already created above)


## correct for intensity inhomogeneities ##
sb_nu_correct_analyze ${pfx}_t1_masked ${pfx}_t1_masked ${pfx}_t1_masked_nu ${nu} 

## get header info (to ensure bounding box for seg is comparatively the same size as for 256x256x124 images) ##
xdim=`fslinfo ${t1}.img | grep "^dim1" | sed "s/dim1 *//"`
ydim=`fslinfo ${t1}.img | grep "^dim2" | sed "s/dim2 *//"`
zdim=`fslinfo ${t1}.img | grep "^dim3" | sed "s/dim3 *//"`
xbox=`echo "${xdim} / 5.3" | bc`
ybox=`echo "${ydim} / 5.3" | bc`
zbox=`echo "${zdim} / 3.4" | bc`

## segment T1 ##
if [ ${dementia} = 0 ]; then
  T1seg_3T ${pfx}_t1_masked_nu ${pfx}_t1_seg -bfgw 0 5 4 3 -win_size 10 -x ${xbox} -y ${ybox} -z ${zbox}  
  ## T1 segmentation to DTI reslice ##
  WarpImageMultiTransform 3 ${pfx}_t1_seg.hdr ${pfx}_seg_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} --use-NN
else
  T1seg_3T ${pfx}_t1_masked_nu ${pfx}_orig_t1_seg -bfgw 0 5 4 3 -win_size 10 -x ${xbox} -y ${ybox} -z ${zbox}
fi


#=======================================================================================
### DEMENTIA SPECIFIC ### 

if [ ${dementia} -eq 1 ]; then 
 
  ## create t1falir ##
  imgmath ${pfx}_fl_to_t1.img -mas ${pfx}_t1_masked.img ${pfx}_fl_to_t1_masked.img
  sb_nu_correct_analyze ${pfx}_fl_to_t1_masked ${pfx}_fl_to_t1_masked ${pfx}_fl_to_t1_masked_nu ${nu}
  FSLOUTPUTTYPE=NIFTI
  export FSLOUTPUTTYPE
  FLEX_normalize ${pfx}_fl_to_t1_masked_nu.img ${pfx}_fl_to_t1_masked_nu_norm.img
  FLEX_normalize ${pfx}_t1_masked_nu.img ${pfx}_t1_masked_nu_norm.img
  fslmaths ${pfx}_fl_to_t1_masked_nu_norm -mul 0.5 ${pfx}_fl_to_t1_masked_nu_norm_mul 
  fslmaths  ${pfx}_t1_masked_nu_norm -add ${pfx}_fl_to_t1_masked_nu_norm_mul ${pfx}_t1flair
  fslmaths ${pfx}_t1flair -mul 100 ${pfx}_t1flair_int -odt short
  imgmath ${pfx}_t1flair_int.nii -thr 0 ${pfx}_t1flair.img
  rm ${pfx}_t1flair_int.nii
  rm ${pfx}_t1flair.nii
  rm ${pfx}_t1_masked_nu_norm.*
  rm ${pfx}_fl_to_t1_masked_nu_norm.*
  rm ${pfx}_fl_to_t1_masked_nu_norm_mul.nii

  xbox=`echo "${xbox} * 1.35" | bc`
  ybox=`echo "${ybox} * 1.35" | bc`
  zbox=`echo "${zbox} * 1.35" | bc`

  T1seg_3T ${pfx}_t1flair ${pfx}_t1_seg -bfgw 0 5 4 3 -win_size 10 -x ${xbox} -y ${ybox} -z ${zbox}
  mask_img ${pfx}_orig_t1_seg ${pfx}_orig_t1_seg -o ${pfx}_orig_t1_csf -m 0 1 2 3 4
  mask_img ${pfx}_t1_seg ${pfx}_orig_t1_csf -m 5
  imgmath ${pfx}_orig_t1_csf.img -add ${pfx}_t1_seg_masked.img ${pfx}_t1_seg.img

  mask_img ${pfx}_orig_t1_seg ${pfx}_orig_t1_seg -o ${pfx}_orig_t1_seg_wm -m 0 1 2 4 5
  mask_img ${pfx}_t1_seg ${pfx}_orig_t1_seg_wm -m 3
  imgmath ${pfx}_orig_t1_seg_wm.img -add ${pfx}_t1_seg_masked.img ${pfx}_t1_seg.img

  rm ${pfx}_t1_seg_masked.*
  rm ${pfx}_orig_t1_csf.*
  rm ${pfx}_orig_t1_wm.*

  WarpImageMultiTransform 3 ${pfx}_t1_seg.hdr ${pfx}_seg_to_dti.hdr -R ${dti}_b0.hdr ${t12dtiParameters} --use-NN
fi
#=======================================================================================

## remove CSF voxels from subcortical regions ##
imgmath ${pfx}_subcortical_to_dti.img -min ${pfx}_subcortical_to_dti.img ${pfx}_subcortical_to_dti.img -short
imgmath ${pfx}_seg_to_dti.img -min ${pfx}_seg_to_dti.img ${pfx}_seg_to_dti.img -short
mask_img ${pfx}_subcortical_to_dti ${pfx}_seg_to_dti -m 0 1 2 5
mv ${pfx}_subcortical_to_dti_masked.img ${pfx}_subcortical_to_dti.img
mv ${pfx}_subcortical_to_dti_masked.hdr ${pfx}_subcortical_to_dti.hdr

#=======================================================================================


cd ../

