<!--!
    This shader is a simplified version of the vertex_shader.html
    It is being used by viewers that display a surface signal and allows for vertex picking.
    It does not handle lines, transparent surfaces or region based coloring.
-->
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aVertexColor;
    uniform mat4 uPMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uNMatrix;
    uniform vec3 uAmbientColor;
    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    uniform float uMaterialShininess;
    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingSpecularColor;
    uniform float isPicking;

    varying vec4 vColor;

    void main(void) {

        vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * mvPosition;

        vec4 transformedNormal = uNMatrix * vec4(aVertexNormal, 1.0);
        float directionalLightWeighting = max(dot(transformedNormal.xyz, uLightingDirection), 0.0);

        vec3 lightDirection = normalize(uPointLightingLocation - aVertexPosition.xyz);
        vec3 normal = normalize(transformedNormal.xyz);
        vec3 eyeDirection = normalize(-aVertexPosition.xyz);
        vec3 reflectionDirection = reflect(-lightDirection, normal);
        float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);

        vec4 materialColor = aVertexColor;
        vec3 vLightWeighting;

        if (isPicking == 0.0){
            vLightWeighting = uAmbientColor  + uDirectionalColor * directionalLightWeighting  + uPointLightingSpecularColor * specularLightWeighting;
        }else{
            vLightWeighting = vec3(1, 1, 1);
            materialColor = vec4(aVertexColor.rgb, 1.0);
        }

        vec3 light = materialColor.rgb * vLightWeighting;
        vColor = vec4(light, materialColor.a);
    }
</script>